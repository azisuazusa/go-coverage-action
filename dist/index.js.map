{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../../../../opt/homebrew/Cellar/ncc/0.38.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"events\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../external node-commonjs \"readline\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":[null,"module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"readline\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst github = require('@actions/github');\n\nconst events = require('events');\nconst { execa } = require('execa');\nconst fs = require('fs');\nconst path = require('path');\nconst readline = require('readline');\n\nconst { version } = require('./package.json');\n\nconst tmpdir = process.env['RUNNER_TEMP'];\nconst ctx = github.context;\n\nconst DATA_FMT_VERSION = 1;\n\nasync function exec(cmd, args, stdin) {\n  try {\n    const wd = core.getInput('working-directory');\n    core.startGroup(`$ ${cmd} ${args.join(' ')}`);\n    const subprocess = execa(cmd, args, {\n      cwd: wd,\n      env: {\n        ...process.env,\n        GIT_AUTHOR_NAME: 'Go Coverage Action',\n        GIT_AUTHOR_EMAIL: '<>',\n        GIT_COMMITTER_NAME: 'Go Coverage Action',\n        GIT_COMMITTER_EMAIL: '<>',\n      },\n      all: true,\n      input: stdin,\n    });\n    subprocess.all.pipe(process.stdout);\n    const { all } = await subprocess;\n    return { output: all };\n  } catch (e) {\n    core.warning(`Failed to run ${cmd} ${args.join(' ')}`);\n    throw e;\n  } finally {\n    core.endGroup();\n  }\n}\n\nasync function setup() {\n  await exec('go', ['version']);\n  await fetchCoverage();\n}\n\nasync function fetchCoverage() {\n  const notesRef = core.getInput('notes-ref');\n  try {\n    const refName = `refs/notes/${notesRef}`;\n    await exec('git', [\n      'fetch',\n      'origin',\n      `+${refName}:${refName}`,\n    ]);\n  } catch (e) {\n    // expected to fail if the ref hasn't been created yet\n    core.info(`no existing ${notesRef} ref`);\n  }\n}\n\nasync function setCoverageNote(data) {\n  const jsdata = JSON.stringify(data);\n  core.startGroup('new coverage raw data');\n  core.info(`new coverage data:  ${jsdata}`);\n  core.endGroup();\n  const notesRef = core.getInput('notes-ref');\n  await fetchCoverage();\n  await exec(\n    'git',\n    ['notes', `--ref=${notesRef}`, 'add', '-f', '--file=-', ctx.sha],\n    jsdata\n  );\n  await exec('git', ['push', 'origin', `refs/notes/${notesRef}`]);\n}\n\nasync function getPriorCoverage() {\n  const stats = { coverage_pct: null, pkg_stats: {} };\n  const pl = ctx.payload;\n  const ref = pl.pull_request ? pl.pull_request.base.sha : pl.before;\n  if (!ref) {\n    return stats;\n  }\n  try {\n    const notesRef = core.getInput('notes-ref');\n    const { output } = await exec('git', [\n      'log',\n      `--notes=${notesRef}`,\n      '--pretty=format:%H%n%N',\n      '--grep=coverage_pct',\n      '-n',\n      '1',\n      ref,\n    ]);\n\n    try {\n      core.startGroup('prior coverage raw data');\n      core.info(`prior coverage data:  ${output}`);\n      core.endGroup();\n      const lines = output.split('\\n');\n      const sha = lines[0];\n      const data = JSON.parse(lines[1]);\n      data['sha'] = sha;\n      return data;\n    } catch (e) {\n      core.info(`failed to decode prior coverage: ${e}`);\n      return stats;\n    }\n  } catch (e) {\n    // git log may fail if an invalid ref is given; that's ok.\n  }\n  core.info(`no prior coverage found`);\n  return stats;\n}\n\nfunction packageDelta(prior, now) {\n  const priorPkgNames = Object.keys(prior);\n  const nowPkgNames = Object.keys(now);\n  const allNames = new Set(priorPkgNames.concat(nowPkgNames));\n  const pkgs = [];\n  for (const pkgName of [...allNames].sort()) {\n    const priorPct = prior[pkgName]?.[0] || 0;\n    const nowPct = now[pkgName]?.[0] || 0;\n    // only count as changed if delta is >0.1%\n    if (Math.abs(priorPct - nowPct) >= 0.1) {\n      pkgs.push([pkgName, priorPct, nowPct]);\n    }\n  }\n  return pkgs;\n}\n\nasync function generateCoverage() {\n  const report = {\n    pkg_count: 0,\n    with_tests: 0,\n    no_tests: 0,\n    skipped_count: 0,\n    coverage_pct: 0,\n    reportPathname: '',\n    gocovPathname: '',\n    gocovAggPathname: '',\n  };\n\n  report.gocovPathname = path.join(tmpdir, 'go.cov');\n  report.gocovAggPathname = path.join(tmpdir, 'go-aggregate.cov');\n\n  const filename = core.getInput('report-filename');\n  report.reportPathname = filename.startsWith('/')\n    ? filename\n    : path.join(tmpdir, filename);\n\n  const coverMode = core.getInput('cover-mode');\n  const coverPkg = core.getInput('cover-pkg');\n\n  let testArgs;\n  try {\n    testArgs = JSON.parse(core.getInput('test-args'));\n    if (!Array.isArray(testArgs)) {\n      throw 'not an array';\n    }\n  } catch (e) {\n    throw `invalid value for test-args; must be a JSON array of strings, got ${testArgs} (${e})`;\n  }\n\n  const args = ['test']\n    .concat(testArgs)\n    .concat([\n      '-covermode',\n      coverMode,\n      '-coverprofile',\n      report.gocovPathname,\n      ...(coverPkg ? ['-coverpkg', coverPkg] : []),\n      './...',\n    ]);\n  await exec('go', args);\n\n  const pkgStats = {};\n  const [globalPct, skippedFileCount, pkgStmts] = await calcCoverage(\n    report.gocovPathname,\n    report.gocovAggPathname\n  );\n  for (const [pkgPath, [stmtCount, matchCount]] of Object.entries(pkgStmts)) {\n    report.pkg_count++;\n    pkgStats[pkgPath] = [(matchCount / stmtCount) * 100];\n    if (matchCount > 0) {\n      report.with_tests++;\n    } else {\n      report.no_tests++;\n    }\n  }\n  report.coverage_pct = globalPct;\n  report.pkg_stats = pkgStats;\n  report.skipped_count = skippedFileCount;\n\n  await exec('go', [\n    'tool',\n    'cover',\n    '-html',\n    report.gocovPathname,\n    '-o',\n    report.reportPathname,\n  ]);\n  core.info(`Generated ${report.reportPathname}`);\n\n  return report;\n}\n\n// parse the go.cov file to calculate \"true\" coverage figures per package\n// regardless of whether coverpkg is used.\nasync function calcCoverage(goCovFilename, aggFilename) {\n  const pkgStats = {};\n  const idCounts = {};\n  let globalStmts = 0; // number of statements globally\n  let globalCount = 0; // number of statements with coverage\n  let skippedFiles = new Set();\n\n  const wl = fs.createWriteStream(aggFilename);\n\n  const ignorePatterns = core\n    .getMultilineInput('ignore-pattern')\n    .map((pat) => new RegExp(pat.trim()));\n  core.info(`Ignoring ${ignorePatterns.length} filename patterns`);\n\n  const rl = readline.createInterface({\n    input: fs.createReadStream(goCovFilename),\n    crlfDelay: Infinity,\n  });\n\n  const re = /^(.+) (\\d+) (\\d+)$/;\n  let mode = 'set';\n  rl.on('line', (line) => {\n    const m = line.match(re);\n    if (!m) {\n      const mm = line.match(/mode:\\s+(\\w+)/);\n      if (mm) {\n        mode = mm[1];\n        core.info(`Mode: ${mode}`);\n      }\n      return;\n    }\n    const id = m[1]; // statement identifier; pkgpath + stmt offset\n    const pkgPath = path.dirname(id);\n    const fn = id.split(':')[0];\n    for (const re of ignorePatterns) {\n      if (fn.match(re)) {\n        if (!skippedFiles.has(fn)) {\n          core.info('Skipping ' + fn);\n        }\n        skippedFiles.add(fn);\n        return;\n      }\n    }\n    const stmtCount = Number(m[2]);\n    const matchCount = Number(m[3]);\n    if (!pkgStats[pkgPath]) {\n      pkgStats[pkgPath] = [0, 0]; // stmts, covered\n    }\n    if (!idCounts[id]) {\n      globalStmts += stmtCount;\n      idCounts[id] = [stmtCount, 0];\n      pkgStats[pkgPath][0] += stmtCount;\n    }\n    if (matchCount > 0 && !idCounts[id][1]) {\n      globalCount += stmtCount;\n      pkgStats[pkgPath][1] += stmtCount;\n    }\n    idCounts[id][1] += matchCount;\n  });\n  await events.once(rl, 'close');\n\n  core.info(`Writing ${Object.keys(idCounts).length} keys`);\n  wl.write(`mode: ${mode}\\n`);\n  for (const id of Object.keys(idCounts).sort()) {\n    const [stmtCount, coverCount] = idCounts[id];\n    wl.write(\n      `${id} ${stmtCount} ${mode == 'set' && coverCount ? 1 : coverCount}\\n`\n    );\n  }\n  wl.end();\n\n  const globalPct = (globalCount / globalStmts) * 100;\n  core.info(\n    `Totals stmts=${globalStmts} covered=${globalCount}, pct=${globalPct}`\n  );\n  return [globalPct, skippedFiles.size, pkgStats];\n}\n\nfunction getCommentMarker() {\n  const notesRef = core.getInput('notes-ref');\n  return `<!-- ${notesRef} -->`;\n}\n\nasync function generatePRComment(stats) {\n  const notesRef = core.getInput('notes-ref');\n  const commentMarker = getCommentMarker();\n  let commitComment = `${commentMarker}\n    ### ðŸŽ‰ New Test Coverage Added for ${notesRef}!\n    Fantastic work! ðŸ‘ You've initiated test coverage at **${stats.current.coverage_pct.toFixed(1)}%**. Each new test helps fortify our codebase. Keep expanding our coverage! ðŸš€`;\n\n  if (stats.prior.coverage_pct != null) {\n    commitComment = `${commentMarker}\n      ### â†”ï¸ Test Coverage Unchanged for ${notesRef}\n      Consistency is key! Let's use this stability as a launchpad to aim higher. Current coverage remains at **${stats.current.coverage_pct.toFixed(1)}%**. Previous commit: ${stats.prior.sha}. More tests mean stronger code! ðŸš€ðŸ’¡`;\n\n    if (stats.deltaPct > 0) {\n      commitComment = `${commentMarker}\n        ### ðŸ“ˆ Increased Test Coverage for ${notesRef}!\n        Fantastic progress! ðŸŽ‰ We're stepping up our testing game, increasing coverage from **${stats.prior.coverage_pct.toFixed(1)}%** (commit: ${stats.prior.sha}) to **${stats.current.coverage_pct.toFixed(1)}%**. Keep pushing forward! ðŸ’»âœ¨`;\n    } else if (stats.deltaPct < 0) {\n      commitComment = `${commentMarker}\n        ### ðŸ›‘ Decreased Test Coverage Alert for ${notesRef}!\n        Not to worry! Let's turn this into a positive. Use this opportunity to strengthen our tests. Previous commit: ${stats.prior.sha}. Previous: **${stats.prior.coverage_pct.toFixed(1)}%**, Current: **${stats.current.coverage_pct.toFixed(1)}%**. We've got this! ðŸ’ª`;\n    }\n    if (stats.current.skipped_count > 0) {\n      commitComment += ` <i>(${stats.current.skipped_count} ignored files)</i>`;\n    }\n  } \n\n  if (stats.current.no_tests > 0) {\n    commitComment += `\\n<details><summary>:warning: ${stats.current.no_tests} of ${stats.current.pkg_count} packages have zero coverage.</summary>\\n\\n`;\n    for (const pkgName of Object.keys(stats.current.pkg_stats).sort()) {\n      if (stats.current.pkg_stats[pkgName] == 0) {\n        commitComment += `* ${pkgName}\\n`;\n      }\n    }\n    commitComment += `\\n</details>\\n`;\n  }\n\n  if (!stats.meetsThreshold) {\n    commitComment += `\\n:no_entry: Coverage does not meet minimum requirement of ${stats.minPct}%.\\n`;\n  }\n\n  const reportUrl = core.getInput('report-url');\n  if (reportUrl) {\n    commitComment += `\\n\\n[View full coverage report](${reportUrl})\\n`;\n  }\n\n  if (stats.prior.coverage_pct !== null) {\n    const delta = packageDelta(stats.prior.pkg_stats, stats.current.pkg_stats);\n    if (delta.length) {\n      const maxPkgLen = Math.max.apply(\n        null,\n        delta.map((pkg) => pkg[0].length)\n      );\n      commitComment += '\\nUpdated Package Coverages:\\n\\n```diff\\n';\n      commitComment += `# ${'Package Name'.padEnd(\n        maxPkgLen,\n        ' '\n      )} |  Prior |    New\\n`;\n      for (const pkg of delta) {\n        const [pkgName, priorPct, newPct] = pkg;\n        const priorPctFmt = priorPct.toFixed(1).padStart(5, ' ') + '%';\n        const newPctFmt = newPct.toFixed(1).padStart(5, ' ') + '%';\n        commitComment += `${newPct >= priorPct ? '+' : '-'} ${pkgName.padEnd(\n          maxPkgLen,\n          ' '\n        )} | ${priorPctFmt} | ${newPctFmt}\\n`;\n      }\n      commitComment += '```\\n\\n';\n    } else {\n      commitComment += `\\nNo change in coverage for any package.\\n\\n`;\n    }\n  }\n\n  const allMaxPkgLen = Math.max.apply(\n    null,\n    Object.keys(stats.current.pkg_stats).map((pkgName) => pkgName.length)\n  );\n  commitComment +=\n    '<details><summary>View coverage for all packages</summary>\\n';\n  commitComment += '\\n```diff\\n';\n  commitComment += `# ${'Package Name'.padEnd(allMaxPkgLen, ' ')} | Coverage\\n`;\n  for (const pkgName of Object.keys(stats.current.pkg_stats).sort()) {\n    const pct = stats.current.pkg_stats[pkgName][0];\n    commitComment += `${pct > 0 ? '+' : '-'} ${pkgName.padEnd(\n      allMaxPkgLen,\n      ' '\n    )} |   ${pct.toFixed(1).padStart(5, ' ')}%\\n`;\n  }\n  commitComment += '```\\n</details>\\n\\n';\n\n  return commitComment;\n}\n\nasync function findPreviousComment(octokit, issue_number) {\n  const it = octokit.paginate.iterator(octokit.rest.issues.listComments, {\n    owner: ctx.payload.repository.owner.login,\n    repo: ctx.payload.repository.name,\n    issue_number: issue_number,\n    per_page: 100,\n  });\n\n  const commentMarker = getCommentMarker();\n\n  for await (const { data: comments } of it) {\n    for (const comment of comments) {\n      if (comment.body.startsWith(commentMarker)) {\n        return comment.id;\n      }\n    }\n  }\n  return null;\n}\n\nasync function generateReport() {\n  await setup();\n\n  const current = await generateCoverage();\n  const prior = await getPriorCoverage();\n  const minPct = Number(core.getInput('coverage-threshold'));\n  const deltaPct = current.coverage_pct - prior.coverage_pct;\n\n  const stats = {\n    current,\n    prior,\n    deltaPct,\n    minPct,\n    meetsThreshold: current.coverage_pct > minPct,\n    deltaPctFmt: Intl.NumberFormat('en-US', {\n      signDisplay: 'exceptZero',\n    }).format(deltaPct),\n  };\n\n  core.info(`Found ${stats.current.pkg_count} packages`);\n  core.info(`Packages with tests: ${stats.current.with_tests}`);\n  core.info(`Packages with zero tests: ${stats.current.no_tests}`);\n  core.info(`Total coverage: ${stats.current.coverage_pct.toFixed(1)}%`);\n  core.info(`Minimum required coverage: ${stats.minPct}%`);\n  core.info(`Coverage delta: ${stats.deltaPctFmt}%`);\n\n  core.startGroup('Set output values');\n  core.setOutput('coverage-pct', stats.current.coverage_pct);\n  core.setOutput('package-count', stats.current.pkg_count);\n  core.setOutput('uncovered-packages', stats.current.no_tests);\n\n  core.setOutput('coverage-delta', stats.deltaPct);\n  core.setOutput('coverage-last-pct', stats.prior.coverage_pct);\n  core.setOutput('coverage-last-sha', stats.prior.sha);\n  core.setOutput('meets-threshold', stats.meetsThreshold);\n  core.setOutput('gocov-pathname', current.gocovPathname);\n  core.setOutput('gocov-agg-pathname', current.gocovAggPathname);\n  core.setOutput('report-pathname', current.reportPathname);\n  core.endGroup();\n\n  const nowData = {\n    'go-coverage-action-fmt': DATA_FMT_VERSION,\n    coverage_pct: current.coverage_pct,\n    pkg_stats: current.pkg_stats,\n    skipped_count: current.skipped_count,\n  };\n  await setCoverageNote(nowData);\n\n  if (!stats.meetsThreshold) {\n    const fail_policy = core.getInput('fail-coverage');\n    if (\n      fail_policy == 'always' ||\n      (fail_policy == 'only_pull_requests' && ctx.payload.pull_request)\n    ) {\n      core.setFailed(\n        `Code coverage of ${stats.current.coverage_pct.toFixed(\n          1\n        )}% falls below minimum required coverage of ${stats.minPct}%`\n      );\n    } else {\n      core.warning(\n        `Code coverage of ${stats.current.coverage_pct.toFixed(\n          1\n        )}% falls below minimum required coverage of ${stats.minPct}%`\n      );\n    }\n  }\n\n  const comment = await generatePRComment(stats);\n  await core.summary.addRaw(comment).write();\n\n  if (core.getBooleanInput('add-comment') && ctx.payload.pull_request) {\n    const token = core.getInput('token');\n    const octokit = github.getOctokit(token);\n    const pr_number = ctx.payload.pull_request.number;\n    const prev_comment_id = await findPreviousComment(octokit, pr_number);\n    if (prev_comment_id) {\n      core.info(`Updating existing comment id ${prev_comment_id}`);\n      await octokit.rest.issues.updateComment({\n        owner: ctx.payload.repository.owner.login,\n        repo: ctx.payload.repository.name,\n        comment_id: prev_comment_id,\n        body: comment,\n      });\n    } else {\n      core.info('Creating new comment');\n      await octokit.rest.issues.createComment({\n        owner: ctx.payload.repository.owner.login,\n        repo: ctx.payload.repository.name,\n        issue_number: pr_number,\n        body: comment,\n      });\n    }\n  }\n}\n\nasync function run() {\n  try {\n    core.info(`Running go-coverage-action version ${version}`);\n\n    await generateReport();\n  } catch (e) {\n    core.setFailed(e);\n  }\n}\n\nrun();\n"],"names":[],"sourceRoot":""}